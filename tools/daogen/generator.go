package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"strings"
	"text/template"
)

// Generator defines the interface for generating code from struct metadata.
type Generator interface {
	Generate(ctx context.Context, pkgName string, metadata *StructMetadata, dialect string) ([]byte, error)
}

// TemplateGenerator is a concrete implementation of Generator using text/template.
type TemplateGenerator struct{}

const daoTemplate = `// Code generated by daogen. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"database/sql"	
)

type {{.StructName}}DAO struct {
	db *sql.DB
}

func New{{.StructName}}DAO(db *sql.DB) *{{.StructName}}DAO {
	return &{{.StructName}}DAO{db: db}
}

func (dao *{{.StructName}}DAO) Get(ctx context.Context, {{.GetArgs}}) (*{{.StructName}}, error) {
	query := "SELECT {{.Columns}} FROM {{.TableName}} WHERE {{.WhereID_Get}}"
	row := dao.db.QueryRowContext(ctx, query, {{.ByIDArgs}})
	var m {{.StructName}}
	err := row.Scan({{.ScanFields}})
	if err != nil {
		return nil, err
	}
	return &m, nil
}

func (dao *{{.StructName}}DAO) Insert(ctx context.Context, m *{{.StructName}}) error {
	query := "INSERT INTO {{.TableName}} ({{.InsertCols}}) VALUES ({{.Placeholders}})"
	_, err := dao.db.ExecContext(ctx, query, {{.InsertArgs}})
	return err
}

func (dao *{{.StructName}}DAO) Update(ctx context.Context, m *{{.StructName}}) error {
	query := "UPDATE {{.TableName}} SET {{.UpdateSet}} WHERE {{.WhereID_Update}}"
	_, err := dao.db.ExecContext(ctx, query, {{.UpdateArgs}})
	return err
}

func (dao *{{.StructName}}DAO) Delete(ctx context.Context, {{.GetArgs}}) error {
	query := "DELETE FROM {{.TableName}} WHERE {{.WhereID_Delete}}"
	_, err := dao.db.ExecContext(ctx, query, {{.ByIDArgs}})
	return err
}
`

// TemplateData holds the data for the DAO template.
type TemplateData struct {
	Package        string
	StructName     string
	TableName      string
	Columns        string
	GetArgs        string
	WhereID_Get    string
	WhereID_Update string
	WhereID_Delete string
	ByIDArgs       string
	ScanFields     string
	InsertCols     string
	Placeholders   string
	InsertArgs     string
	UpdateSet      string
	UpdateArgs     string
}

// Generate produces the Go source code for the DAO.
func (g *TemplateGenerator) Generate(ctx context.Context, pkgName string, metadata *StructMetadata, dialect string) ([]byte, error) {
	tmpl, err := template.New("dao").Parse(daoTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	data := g.prepareData(pkgName, metadata, dialect)

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.Bytes(), nil
}

func toArgName(name string) string {
	if name == "ID" {
		return "id"
	}
	if len(name) == 0 {
		return ""
	}
	return strings.ToLower(name[:1]) + name[1:]
}

func (g *TemplateGenerator) prepareData(pkgName string, metadata *StructMetadata, dialect string) TemplateData {
	data := TemplateData{
		Package:    pkgName,
		StructName: metadata.StructName,
		TableName:  metadata.TableName,
	}

	var cols, scanFields, insertCols, placeholders, insertArgs, updateSet, updateArgs []string
	var getArgs, byIDArgs []string

	// Helper for placeholders
	getPlaceholder := func(c *int) string {
		if dialect == "postgres" {
			p := fmt.Sprintf("$%d", *c)
			*c++
			return p
		}
		return "?"
	}

	// 1. Basic Metadata & Scanning
	for _, f := range metadata.Fields {
		cols = append(cols, f.ColumnName)
		scanFields = append(scanFields, "&m."+f.FieldName)

		if f.IsIdentifier {
			argName := toArgName(f.FieldName)
			getArgs = append(getArgs, fmt.Sprintf("%s %s", argName, f.FieldType))
			byIDArgs = append(byIDArgs, argName)
		}

		if !f.IsIdentifier { // Phase 2 default: insert all non-ID
			insertCols = append(insertCols, f.ColumnName)
			insertArgs = append(insertArgs, "m."+f.FieldName)
		}
	}

	// 2. GET & DELETE WHERE
	counter := 1
	var whereGD []string
	for _, f := range metadata.Fields {
		if f.IsIdentifier {
			whereGD = append(whereGD, f.ColumnName+" = "+getPlaceholder(&counter))
		}
	}
	data.WhereID_Get = strings.Join(whereGD, " AND ")
	data.WhereID_Delete = data.WhereID_Get

	// 3. INSERT
	counter = 1
	for range insertCols {
		placeholders = append(placeholders, getPlaceholder(&counter))
	}

	// 4. UPDATE
	counter = 1
	for _, f := range metadata.Fields {
		if f.IsUpdatable {
			updateSet = append(updateSet, f.ColumnName+" = "+getPlaceholder(&counter))
			updateArgs = append(updateArgs, "m."+f.FieldName)
		}
	}
	var whereUpdate []string
	for _, f := range metadata.Fields {
		if f.IsIdentifier {
			whereUpdate = append(whereUpdate, f.ColumnName+" = "+getPlaceholder(&counter))
			updateArgs = append(updateArgs, "m."+f.FieldName)
		}
	}
	data.WhereID_Update = strings.Join(whereUpdate, " AND ")

	data.Columns = strings.Join(cols, ", ")
	data.ScanFields = strings.Join(scanFields, ", ")
	data.GetArgs = strings.Join(getArgs, ", ")
	data.ByIDArgs = strings.Join(byIDArgs, ", ")
	data.InsertCols = strings.Join(insertCols, ", ")
	data.Placeholders = strings.Join(placeholders, ", ")
	data.InsertArgs = strings.Join(insertArgs, ", ")
	data.UpdateSet = strings.Join(updateSet, ", ")
	data.UpdateArgs = strings.Join(updateArgs, ", ")

	return data
}

// WriteFile writes the generated code to the specified output path.
func WriteFile(path string, content []byte) error {
	return os.WriteFile(path, content, 0644)
}
